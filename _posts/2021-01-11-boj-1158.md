---
title: "[백준/Baekjoon] 1158번: 요세푸스 문제"
excerpt: "[백준/Baekjoon] 1158번: 요세푸스 문제"
toc: true
toc_sticky: true

categories:
  - Problem Solving
tags:
  - Problem Solving
  - Baekjoon
  - Python
  - Linked Lists
last_modified_at: 2021-01-11T12:00:00-05:00
---

## 1. 문제

요세푸스 문제는 다음과 같다.

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.

## 2. 입력

첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)

## 3. 출력

예제와 같이 요세푸스 순열을 출력한다.

## 4. 예제 입력 1

> 7 3

## 5. 예제 출력 1

> <3, 6, 2, 7, 5, 1, 4>

## 6. 풀이

리스트에서 주어진 값 K 만큼 인덱스를 증가시키며 값을 제거한다.
이 때 리스트는 원형이므로 인덱스 값을 계산할 때 항상 리스트의 크기로 나눈 나머지를 구해야 한다.

```python
idx = (idx + (k - 1)) % len(data)
```

인덱스 값을 갱신할 때 K에서 1을 뺀 값으로 계산하는 이유 다음과 같다.

1. 처음으로 갱신할 때는 인덱스의 시작이 1이 아닌 0으로 시작하기 때문이다.
2. 이후에는 인덱스의 값을 제거하게 되면, 리스트의 모든 값이 앞으로 1칸 당겨지게 되므로 이미 1칸 이동한 것과 같기 때문이다.

## 7. 코드

```python
n, k = map(int, input().split())
idx = 0
result = []

data = [x for x in range(1, n + 1)]

while data:
    idx = (idx + (k - 1)) % len(data)
    temp = data.pop(idx)
    result.append(temp)

print('<' + str(result)[1:-1] + '>')

```
